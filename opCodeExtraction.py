#Opcode Extraction
import os

#malwareFileLocation = "C:\\Users\\Ben\\Desktop\\Malware"
malwareFileLocation = "F:\\Malware\\train\\train"

listOfFiles = os.listdir(malwareFileLocation)
listOfFiles.sort()

listOfOpcodes = set()

with open(malwareFileLocation+"\\featuresExtracted", "w", encoding="latin-1") as featureFile:
	for fileName in listOfFiles:
		#Ignore byte file and the featureExtracted File
		if(".bytes" in fileName or "featuresExtracted" in fileName or "freqTrainingData" in fileName):
			continue
		
		#Extract all the different type of opcode
		with open(malwareFileLocation+"\\"+fileName, "r", encoding="latin-1") as reader:
			print(str(listOfFiles.index(fileName)/2) + " Opening: " + fileName)
			#Calculate frequency of opcode, how to handle aggregated opcode like movjz?
			for line in reader:
				#Look only at text which is byte code so break when it enters data section
				if not(".text" in line or "HEADER" in line):
					break
				
				#Check if value is a hex value
				splittedData = line.split()
				try:
					int(splittedData[1], 16)
					#Could be something like dd if hex then will be upper
					if(splittedData[1].islower()):
						continue
				except:
					continue
				
				#Reiterate till non hex which is the opcode
				for a in range(2, len(splittedData)):
					#Check if it is hex
					try:
						int(splittedData[a], 16)
					except:
						#To deal with hex+ ending
						if(len(splittedData[a])> 2 and "+" == splittedData[a][2] and a+1<len(splittedData)):
							listOfOpcodes.add(splittedData[a+1])
						#If is not all alpha means it is not an opcode
						elif splittedData[a].isalpha() and splittedData[a].islower():
							listOfOpcodes.add(splittedData[a])
						break
					#Issue with skipping dd and db
						
					if(a == len(splittedData)-1):
						featureFile.write("Something when wrong when looking in " + fileName + "\n")
						featureFile.write(line)
	featureFile.write(",".join(listOfOpcodes))

